/**********************************************************************
*
* Motorola Inc.
* (c) Copyright 2000 Motorola, Inc.
* ALL RIGHTS RESERVED.
*
***********************************************************************
*
* File Name: testLoopback.c
*
* Description: Does Analog and Digital self loopback tests for both
*              V22 1200 bps and V22 2400 bps modem
*
* Modules Included:
*                   testLoopback ()
*                   TXCallbackRoutine ()
*                   RXCallbackRoutine ()
*
* Author : Sanjay Karpoor
*
* Date   : 13 Sept 2000
*
**********************************************************************/

#include "test.h"
#include "assert.h"
#include "mem.h"

/* V22bis library related header file */
#include "v22bis.h"

/* Codec related header files */
#include "bsp.h"
#include "fcntl.h"
#include "codec.h"

extern  void TXCallbackRoutine (void * pCallbackArg, v22bis_eStatus Status, 
                                Word16 * pSamples, UWord16 NumberSamples);
extern  void RXCallbackRoutine (void * pCallbackArg, v22bis_eStatus Status,
                                char * pBits, UWord16 NumberBits);

EXPORT Result testLoopback (void);

char  Inbuffer[100] = "This is digital and analog loopback testing for v22bis";                     
#define  NUMBER_BYTES  54                   
char     Outbuffer[100];

/* Codec TX & RX buffers and variables */
Word16   CodecTxBuffer[12];  /* Samples generated by the transmitter */
Word16   CodecRxBuffer[12];  /* Samples for the receiver */
Word16   Codec;

UWord16   num_rx_bytes, connection_established, connection_lost;
         
v22bis_sTXCallback  v22bis_TXCallback;         
v22bis_sRXCallback  v22bis_RXCallback;         
         

#define  NUMRX_SAMPLES   12             

#define  DIGITAL_LOOPBACK   1
#define  ANALOG_LOOPBACK    2
    

/**********************************************************************
*
* Module: testLoopback ()
*
* Description: To test for both Digital and Analog Loopback. Both 
*              of them use the same input buffer for the loopback
*              test
*
* Returns: PASS or FAIL
*
* Arguments: None
*
* Range Issues: None
*
* Special Issues: None
*
* Test Method: loopback_test.mcp
*
**************************** Change History **************************
*
*    DD/MM/YY     Code Ver    Description       Author
*    --------     --------    -----------       ------
*    12-04-2000   0.0.1       Created           Sanjay Karpoor
*    13-09-2000   1.0.0       Reviewed and      Sanjay Karpoor
*                             Baselined 
*
**********************************************************************/
                        
Result testLoopback ()
{
  
    v22bis_sHandle     *V22bisInstance;
    v22bis_sConfigure  *pConfig;
    
    bool      message_transmitted;
    UWord16   lastword_counter;
    
    /* Codec structure */
	codec_sParams CodecParams;
		  
    Result  result, i;
    UWord16 modem_config, txword, num_words, loopback_test, num_loopback;
    
    test_sRec      testRec;
    testStart (&testRec, "test V.22bis data pump");  

/*-----------------------------------------------------------------------*

    Testing for both DIGITAL and ANALOG Loopback
	
*------------------------------------------------------------------------*/

    /* Codec initialization */
	Codec = open(BSP_DEVICE_NAME_CODEC_0, O_RDWR);

	CodecParams.Buffer.Size      = 24;
	CodecParams.Buffer.Threshold = 0;

	ioctl(Codec, CODEC_DEVICE_RESET, (void *) &CodecParams);


  /* LOOPBACK TEST
   ****************
   */       

  loopback_test = DIGITAL_LOOPBACK;

  for ( num_loopback = 0; num_loopback < 2; num_loopback++)
  {
  
    if (loopback_test == DIGITAL_LOOPBACK)
	    testComment (&testRec, "testing V22bis Digital Loopback...");
    else
	    testComment (&testRec, "testing V22bis Analog Loopback...");


/*************************************************************************

    At the end of DIGITAL LOOPBACK test, the level0 interrupts are
    masked to enable printing of results. When we come back in a loop
    again for ANALOG LOOPBACK test the interrupts need to be enabled     */
    
    archEnableInt ();     

/*************************************************************************/
	

	/* Initialize the receive buffer to zeros */
	for ( i = 0; i < NUMBER_BYTES; i++)
	      Outbuffer[i] = 0;
	      
	/* Initialize the flow control parameters for loopback testing */
	num_rx_bytes = 0;                   /* Will be used in the Rx Callback
	                                       routine */
    connection_established = 0;         /* Will be set in the TX Callback 
                                           routine */     
    connection_lost = 0;                /* Will be set in the RX Callback 
                                           routine */
	
	/* Modem configuration parameters, typically done after V8bis
	   exchanges the capabilities
	 */
	 
	modem_config = 0;   
	modem_config = (V22BIS_CALL_MODEM | V22BIS_GUARD_TONE_DISABLE | 
	                V22BIS_SELF_RETRAIN_ENABLE | V22BIS_LOOPBACK_ENABLE |
	                V22BIS_V14_DISABLE_ASYNC_MODE);


    /* Allocate memory for the init structure */
    pConfig = memMallocEM( sizeof(v22bis_sConfigure));
    
    v22bis_TXCallback.pCallback = TXCallbackRoutine;
    v22bis_RXCallback.pCallback = RXCallbackRoutine;
    
    /* Initialize the init structure */
    pConfig ->Flags = modem_config;
    pConfig ->TXCallback = v22bis_TXCallback;
    pConfig ->RXCallback = v22bis_RXCallback;
    
    /* Initialize v22bis algorithm */
    V22bisInstance = v22bisCreate (pConfig);
    
    lastword_counter = 0;
    message_transmitted = false;
    
    /*  initialize the modem transmit buffer */
    v22bisTXDataInit ( V22bisInstance, Inbuffer, NUMBER_BYTES);
            
    /* Main loop */
    while ( message_transmitted == false)
    {
    
        num_words = 0;

        do {

			num_words += read(Codec, (CodecRxBuffer + num_words),
			             NUMRX_SAMPLES - num_words);

		   } while (num_words < NUMRX_SAMPLES);		  
    

        /* For digital loopback */
        
        if (loopback_test == DIGITAL_LOOPBACK)
        {
            for ( i = 0; i < NUMRX_SAMPLES; i++)
            {
                CodecRxBuffer[i]  = CodecTxBuffer[i];
            }
        }    
                      
        
        if ( connection_established == 1)
        {
                
            result = v22bisTX (V22bisInstance);
            
            if (result == FAIL)
            {                
              /* Call V22bisRX 15 times to get the delayed bits from the
                 receiver. In the real application this will be take 
                 care off by the immediate higher level protocol. The 
                 user need not worry about these delayed bits. The 
                 minimum number of times the below loop is to be executed
                 is only 10. A sufficient recommended number is 15.
               */
               
                if ( lastword_counter == 15)
                    message_transmitted = true;            
                lastword_counter++;
            }    
        } 
      

        result = v22bisRX ( V22bisInstance, CodecRxBuffer, NUMRX_SAMPLES);
        
        if (connection_lost == 1)
        { 
            message_transmitted = true;
        }    
                    
    }     
	    
    

/*************************************************************************/
    archDisableInt ();    /* To disable the ISRs while printing */
/*************************************************************************/


    if (connection_lost == 1)
    {
       if ( loopback_test == DIGITAL_LOOPBACK)
	        testComment (&testRec, "Connection lost for Digital Loopback");
       else
	        testComment (&testRec, "Connection lost for Analog Loopback");
	}        
    
    
    /* Compare the tx and rx data for any bit errors in loopback */
    
    result = PASS;
    
    for ( num_rx_bytes = 0; num_rx_bytes < NUMBER_BYTES; num_rx_bytes++)
    {
        if ( Inbuffer[num_rx_bytes] != Outbuffer[num_rx_bytes])
	         result = FAIL;
	}                 	
	
	if (result == FAIL)
	{
       if ( loopback_test == DIGITAL_LOOPBACK)
    	    testComment (&testRec, "Digital Loopback test Failed");
       else
    	    testComment (&testRec, "Analog Loopback test Failed");
    }
    	    
	else
	{    
       if ( loopback_test == DIGITAL_LOOPBACK)
    	    testComment (&testRec, "Digital Loopback test Passed");
       else
    	    testComment (&testRec, "Analog Loopback test Passed");
    }
    
    loopback_test = ANALOG_LOOPBACK;
    	    
  }


  close(Codec);     /* codec is NOT DISABLED */

  free (pConfig);     /* Deallocate the memory */

  return (result);     

}
	
		
/**********************************************************************
*
* Module: TXCallbackRoutine ()
*
* Description: This is a V22 transmit callback routine. This module is
*              called by V22bis library as and when it has samples
*              to be sent across to the remote modem.
* 
* Returns: None
*
* Arguments: pCallbackArg -> Supplied by the user in the 
*                            v22bis_TXCallback structure; this value is 
*                            passed back to the user during the call
*                            to the Callback procedure. pCallbackArg
*                            typically points to context information
*                            used by the user's callback procedure 
*                            (user has to write his/her own callback
*                            function)
*            Status - This is an enum containing the following fields
*                      V22BIS_1200BPS_CONNECTION_ESTABLISHED,
*                      V22BIS_2400BPS_CONNECTION_ESTABLISHED,
*                      V22BIS_CONNECTION_LOST,
*                      V22BIS_DATA_AVAILABLE,
*                      V22BIS_RETRAINING
*
*            pSamples -> Pointer to the buffer containing 16-bit
*                        linear samples for transmission to the 
*                        remote modem
*
*            NumberSamples - Number of samples in the sample
*                            buffer pointer by pSamples
*
* Range Issues: None
*
* Special Issues: None
*
* Test Method: loopback_test.mcp
*
**************************** Change History **************************
*
*    DD/MM/YY     Code Ver    Description       Author
*    --------     --------    -----------       ------
*    12-04-2000   0.0.1       Created           Sanjay Karpoor
*    13-09-2000   1.0.0       Reviewed and      Sanjay Karpoor
*                             Baselined 
*
**********************************************************************/

void TXCallbackRoutine (void * pCallbackArg, v22bis_eStatus Status, 
                        Word16 * pSamples, UWord16 NumberSamples)
{

    Word16  i;
    
    if ( (Status == V22BIS_1200BPS_CONNECTION_ESTABLISHED) ||
         (Status == V22BIS_2400BPS_CONNECTION_ESTABLISHED) )
    {     
         connection_established = 1;
    }     
         
    if ( Status == V22BIS_DATA_AVAILABLE)
    {    
    
        for  ( i = 0; i < NumberSamples; i++)
             CodecTxBuffer[i] = pSamples[i]; 
             
		write(Codec, CodecTxBuffer, NumberSamples);                 
             
    }
    
}    


/**********************************************************************
*
* Module: RXCallbackRoutine ()
*
* Description: This is a V22 recive callback routine. This module is
*              called by V22bis library as and when it receives
*              few bits .
* 
* Returns: None
*
* Arguments: pCallbackArg -> Supplied by the user in the 
*                            v22bis_TXCallback structure; this value is 
*                            passed back to the user during the call
*                            to the Callback procedure. pCallbackArg
*                            typically points to context information
*                            used by the user's callback procedure 
*                            (user has to write his/her own callback
*                            function)
*            Status - This is an enum containing the following fields
*                      V22BIS_1200BPS_CONNECTION_ESTABLISHED,
*                      V22BIS_2400BPS_CONNECTION_ESTABLISHED,
*                      V22BIS_CONNECTION_LOST,
*                      V22BIS_DATA_AVAILABLE,
*                      V22BIS_RETRAINING
*
*            pBits -> Pointer to the buffer containing the bits
*                     received / decoded
*
*            NumberSamples - Number of bits received pointed by pBits
*
* Range Issues: None
*
* Special Issues: None
*
* Test Method: loopback_test.mcp
*
**************************** Change History **************************
*
*    DD/MM/YY     Code Ver    Description       Author
*    --------     --------    -----------       ------
*    12-04-2000   0.0.1       Created           Sanjay Karpoor
*    13-09-2000   1.0.0       Reviewed and      Sanjay Karpoor
*                             Baselined 
*
**********************************************************************/

void RXCallbackRoutine (void * pCallbackArg, v22bis_eStatus Status,
                        char * pBits, UWord16 NumberBits)
{

    UWord16  num_bytes, i;
        
    if ( Status == V22BIS_CONNECTION_LOST)
         
         connection_lost = 1;

    if ( Status == V22BIS_DATA_AVAILABLE)
    {
       
         num_bytes =  NumberBits >> 3;
                 
         for ( i = 0; i < num_bytes; i++);
         {
             Outbuffer[num_rx_bytes] = *pBits++;
             num_rx_bytes++;             
         }
    }         
    
}                     
